/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <execinfo.h> // backtrace and backtrace_symbols func
#include <cxxabi.h> // __cxa_demangle
#include <string.h>
#include <memory>

#include "swift/base/Exception.h"

namespace swift {
namespace {

// The prefix used for mangled symbols, per the Itanium C++ ABI:
// http://www.codesourcery.com/cxx-abi/abi.html#mangling
const char kMangledSymbolPrefix[] = "_Z";

// Characters that can be used for symbols, generated by Ruby:
// (('a'..'z').to_a+('A'..'Z').to_a+('0'..'9').to_a + ['_']).join
const char kSymbolCharacters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

// Demangles C++ symbols in the given text. Example:
// "out/Debug/base_unittests(_ZN10StackTraceC1Ev+0x20) [0x817778c]"
// =>
// "out/Debug/base_unittests(StackTrace::StackTrace()+0x20) [0x817778c]"
inline void DemangleSymbol (std::string* symbol) 
{
    std::string::size_type search_from = 0;
    while (search_from < symbol->size ()) {
        // Look for the start of a mangled symbol from search_from
        std::string::size_type mangled_start = symbol->find (kMangledSymbolPrefix, search_from);
        if (mangled_start == std::string::npos) {
            break; // Mangled symbol not found
        }

        // Look for the end of the mangled symbol
        std::string::size_type mangled_end = symbol->find_first_not_of (kSymbolCharacters, mangled_start);
        if (mangled_end == std::string::npos) {
            mangled_end = symbol->size ();
        }
        std::string mangled_symbol = std::move (symbol->substr (mangled_start, mangled_end - mangled_start));

        // Try to demangle the mangled symbol candidate
        int status = -4; // some arbitrary value to eliminate the compiler warning
        std::unique_ptr<char, void(*)(void*)> demangled_symbol {
            abi::__cxa_demangle (mangled_symbol.c_str (), nullptr, 0, &status),
            std::free
        };

        // 0 Demangling is success
        if (0 == status) {
            // Remove the mangled symbol
            symbol->erase (mangled_start, mangled_end - mangled_start);
            // Insert the demangled symbol
            symbol->insert (mangled_start, demangled_symbol.get ());
            // Next time, we will start right after the demangled symbol
            search_from = mangled_start + strlen (demangled_symbol.get ());
        }
        else {
            // Failed to demangle. Retry after the "_Z" we just found
            search_from = mangled_start + 2;
        }
    }
}
} // namespace

// public
Exception::Exception (const char* msg) : msg_ (nullptr == msg ? "" : msg)
{
    ProcessStackTrace ();
}

// public
Exception::Exception (const std::string& msg) : msg_ (msg)
{
    ProcessStackTrace ();
}

// public
Exception::Exception (std::string&& msg) : msg_ (std::move (msg))
{
    ProcessStackTrace ();
}

// public
Exception::~Exception () throw ()
{

}

// public
const char* Exception::GetStackTrace () const throw ()
{
    return stack_.c_str ();
}

// public
const char* Exception::what () const throw ()
{
    return msg_.c_str ();
}

// private
void Exception::ProcessStackTrace ()
{
    void* buf[512];
    int size = ::backtrace (buf, 512);
    std::unique_ptr<char*, void(*)(void*)> stacks {
        ::backtrace_symbols (buf, size),
        std::free
    };

    if (nullptr != stacks.get ()) {
        for (int i = 0; i < size; ++i) {
            std::string symbol (stacks.get ()[i]);
            DemangleSymbol (&symbol);
            stack_.append (symbol);
            stack_.push_back ('\n');
        }
    }
}

} // namespace swift
